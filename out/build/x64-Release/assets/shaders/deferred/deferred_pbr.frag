#version 450
#include"../octmap.glsl"
#include"const.glsl"
#define Bias 0.0f
#define WidthLight 175.0f
#define SizeFilter 20.0f
#define g_kNumCascades 3
out vec4 FragColor;in vec2 TexCoords;struct PointLight{vec3 pos;float padding1;vec3 color;float padding2;};struct DirectionalLight{vec3 direction;float padding1;vec3 color;float padding2;};struct SpotLight{vec3 pos;float n1;vec3 direction;float cutoff;vec3 color;float outerCutoff;};layout(std140, binding = 7)uniform LightBlock{int numPointLights;int numDirLights;int numSpotLights;int _padding;PointLight pointLights[15];DirectionalLight dirLights[2];SpotLight spotLights[2];};struct Fragment{vec3 pos;vec3 albedo;vec3 normal;float metallic;float roughness;float ao;};layout(binding=1)uniform samplerCube irradianceMap;layout(binding=2)uniform samplerCube prefilterMap;layout(binding=3)uniform sampler2D brdfLUT;layout(binding=4)uniform sampler2DArrayShadow shadowMapPCF;layout(binding=5)uniform sampler2DArray shadowMapDepth;layout(binding=6)uniform sampler2D depth;layout(binding=7)uniform sampler2D GBuffer0;layout(binding=8)uniform sampler2D GBuffer1;layout(binding=9)uniform sampler2D GBuffer2;layout(binding=10)uniform sampler2D Noise;layout(std140, binding = 6)uniform Matrices{mat4 projection;mat4 view;};uniform float AVsFarCascade[g_kNumCascades];uniform mat4 ReferenceShadowMatrix;uniform vec3 AOffsetCascade[g_kNumCascades],AScaleCascade[g_kNumCascades];uniform mat4 invVP;uniform vec3 viewPos;vec3 t(float t){if(t>=1.)return vec3(0);vec4 e=invVP*vec4(TexCoords*2.-1.,t*2.-1.,1);e/=e.w;return e.xyz;}float t(vec3 t,int i,vec3 a){t=(t+AOffsetCascade[i].xyz)*AScaleCascade[i].xyz;vec2 c=SizeFilter.xx*abs(AScaleCascade[i].xy),n=textureSize(shadowMapPCF,0).xy;const float s=clamp(t.z-Bias,0,1);vec2 f=gl_FragCoord.xy/vec2(textureSize(Noise,0));float l=texture(Noise,f).x*2*3.1415;const mat2x2 d=mat2x2(vec2(cos(l),-sin(l)),vec2(sin(l),cos(l)));const vec2 r=max(vec2(0),.5*abs(c)/n);l=0;int m=0;for(uint f=0;f<10;++f){const vec2 c=d*DiscVogelSorted[f]*r+t.xy;const float n=texture(shadowMapDepth,vec3(c,i)).x;if(n<s)l+=n,++m;}if(m==0)return 1;if(m==10)return 0;l/=m;const float e=clamp(abs(WidthLight*(s-l)/l)/10,.1,1.);l=0.f;for(int f=0;f<10;++f){const vec2 m=d*DiscVogelSorted[f]*r*e+t.xy;l+=texture(shadowMapPCF,vec4(m,i,s));}return l/10;}float t(vec3 a,float i,float r,vec3 c){c=(ReferenceShadowMatrix*vec4(a,1)).xyz;int n=g_kNumCascades-1;for(int i=g_kNumCascades-1;i>=0;--i){vec2 t=abs((c.xy+AOffsetCascade[i].xy)*AScaleCascade[i].xy-.5f);if(t.x<=.5f&&t.y<=.5f)n=i;}const vec3 s=(ReferenceShadowMatrix*vec4(a,1)).xyz;r=t(s,n,a);float f=AVsFarCascade[n],l=n==0?f:f-AVsFarCascade[n-1];f=(f-i)/l;c=abs((c+AOffsetCascade[n].xyz)*AScaleCascade[n].xyz*2.f-1.f);f=max(1.f-max(max(c.x,c.y),c.z),f);if(f<=.2f&&n!=g_kNumCascades-1){const float c=t(s,n+1,a),l=smoothstep(0.f,.2f,f);r=mix(c,r,l);}return r;}vec3 t(float t,vec3 numDirLights){return numDirLights+(1.-numDirLights)*pow(clamp(1.-t,0.,1.),5.);}float t(vec3 t,vec3 numDirLights,float viewPos){viewPos*=viewPos;viewPos*=viewPos;float e=max(dot(t,numDirLights),0.);e=e*e*(viewPos-1.)+1.;e*=acos(-1.)*e;return viewPos/e;}float t(float t,float view){view+=1.;view=view*view/8.;return t/(t*(1.-view)+view);}float t(vec3 dirLights,vec3 numDirLights,vec3 e,float o){return t(max(dot(dirLights,e),0.),o)*t(max(dot(dirLights,numDirLights),0.),o);}void main(){vec3 s=t(texelFetch(depth,ivec2(gl_FragCoord.xy),0).x),f=signed_oct_to_float32x3(texelFetch(GBuffer1,ivec2(gl_FragCoord.xy),0).xyz);f=normalize(f);const float v=texture2D(GBuffer2,TexCoords).x;vec3 n=texture2D(GBuffer0,TexCoords).xyz;const float c=texture2D(GBuffer2,TexCoords).y;vec3 i=normalize(viewPos-s),l=mix(vec3(.04),n,c),d=l+(max(vec3(1.-v),l)-l)*pow(clamp(1.-max(dot(f,i),0.),0.,1.),5.);vec2 m=texture(brdfLUT,vec2(max(dot(f,i),0.),v)).xy;vec3 r=vec3(0);for(int m=0;m<numPointLights;++m){vec3 d=normalize(pointLights[m].pos-s),e=normalize(d+i);float o=length(pointLights[m].pos-s);vec3 a=pointLights[m].color*(1./(o*o)),u=t(max(dot(e,i),0.),l);r+=((vec3(1)-u)*(1.-c)*n/acos(-1.)+t(f,e,v)*t(f,i,d,v)*u/(4.*max(dot(f,i),0.)*max(dot(f,d),0.)+1e-4))*a*max(dot(f,d),0.);}vec3 e=vec3(0);for(int m=0;m<numSpotLights;++m){SpotLight d=spotLights[m];vec3 r=normalize(d.pos-s);float o=dot(r,normalize(-d.direction));if(o>d.outerCutoff){float m=length(d.pos-s);vec3 viewPos=normalize(r+i),numDirLights=t(max(dot(viewPos,i),0.),l);e+=((vec3(1)-numDirLights)*(1.-c)*n/acos(-1.)+t(f,viewPos,v)*t(f,i,r,v)*numDirLights/(4.*max(dot(f,i),0.)*max(dot(f,r),0.)+1e-4))*(d.color*(1./(m*m))*smoothstep(0.,1.,(o-d.outerCutoff)/(d.cutoff-d.outerCutoff)))*max(dot(f,r),0.);}}vec3 g=vec3(0);for(int m=0;m<numDirLights;++m){vec3 d=normalize(-dirLights[m].direction),r=normalize(d+i),e=dirLights[m].color,a=t(max(dot(r,i),0.),l);float o=max(dot(f,d),0.);const vec3 u=vec3(view*vec4(s,1));const float p=t(s,-u.z,o,f);g+=((vec3(1)-a)*(1.-c)*n/acos(-1.)+t(f,r,v)*t(f,i,d,v)*a/(4.*max(dot(f,i),0.)*max(dot(f,d),0.)+1e-4))*e*o*p;}const vec3 p=(1.-d)*(1.-c)*(texture(irradianceMap,f).xyz*n)+textureLod(prefilterMap,reflect(-i,f),v*4.).xyz*(d*m.x+m.y)+g+r+e+texture2D(GBuffer0,TexCoords).w*n;FragColor=vec4(p,1);}